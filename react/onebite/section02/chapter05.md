# 원시타입 VS 객체타입

- 원시타입과 객체타입을 나눈 이유?
  - 원시타입과 객체타입은 값이 저장되거나 복사되는 과정이 서로 다르기 때문

### 원시타입

- 값 자체로써 변수에 저장되고 복사된다.
- 원시 타입의 값이 저장되고 복사되고 변경되는 과정에서 변수의 값이 수정되더라도 메모리에 한 번 저장되었던 원본 데이터가 수정되지는 않기 때문에 원시 타입의 값들을 불변 값이라고 함
- 주의! 상수여서 불변값이라는 의미 X, 실제 메모리 공간에 저장된 원본 데이터의 값이 변경되지 않는다는 의미

1. Number
2. String
3. Boolean
4. Null
5. Undefined

### 객체타입

- 참조값을 통해 변수에 저장되고 복사된다.
- 메모리 어딘가에 객체를 따로 저장해 둔 다음 변수에는 객체 값이 저장된 메모리 공간을 가리키는 주소값인 참조값을 저장
- 객체 타입의 값들을 참조값으로 저장하는 이유? 객체 값들은 원시 타입의 값들과 다르게 여러 값을 저장함과 동시에 저장하는 값의 개수가 동적으로 유연하게 늘어났다가 줄어들기도 하기 때문에 별도의 메모리 공간에 보관

```js
let o1 = { name: "이정환" };
let o2 = o1;

o2.name = "홍길동";
```

- o1과 o2가 가리키는 객체가 같아져 o2.name으로 값을 변경하면 o1.name도 같이 변경됨 -> 원본 데이터를 수정함
- 객체 타입 값은 원시 타입과 다르게 메모리상에서 값이 수정되어버리기 때문에 가변값이라고 부름

- Object

  - Array
  - Function
  - RegexExp

### 객체타입 주의사항

1. 의도치 않게 값이 수정될 수 있다.

- 의도하지 않았는데 하나의 변화가 또 다른 변수의 변화를 가져오는 것을 Side Effect라고 부르기도 함
- 객체 값을 복사할 때는 대입 연산자로 변수의 이름을 서서 변수의 참조 값 자체를 복사하도록 하는게 아니라 새로운 객체를 생성하고 그 내부에 ... (spread)연산자를 이용해 새로운 객체를 생성하면서 내부 프로퍼티만 복사해오는 방식으로 객체를 복사해와야 함 -> 메모리 상에서도 새로운 참조 값에 새로운 객체로 따로 저장이 됨

```js
// 깊은 복사
let o1 = { name: "이정환" };
let o2 = { ...o1 };
```

2. 객체 간의 비교는 기본적으로 참조값을 기준으로 이루어진다.

```js
let o1 = { name: "이정환" };
let o2 = o1;
let o3 = { ...o1 };

console.log(o1 === o2); // true
console.log(o1 === o3); // false

console.log(JSON.stringify(o1) === JSON.stringify(o3));
```

- o1과 o3는 속성 값은 같지만 서로 다른 객체로, 참조값이 서로 다른 두 객체이기 때문에 서로 다르다고 평가됨
- 참조값이 아닌 프로퍼티를 기준으로 두 객체를 비교하고 싶다면 JSON.stringify 같은 객체를 문자열로 형변환하는 내장 함수를 이용해 참조값이 아닌 프로퍼티를 기준으로 비교하도록 설정해줘야 함
- JSON Stringify는 JavaScript의 내장함수로, 객체를 문자열로 변환하는 기능만 한다고 생각하면 됨
- o1 === o2는 얕은 비교 : 참조값을 기준으로 비교 (참조값을 기준으로 비교하려고 할 때)
- JSON.stringify(o1) === JSON.stringify(02)는 깊은 비교 : 객체를 문자열로 변환하여 비교 (프로퍼티 값을 기준으로 비교하려고 할 때)

3. 배열과 함수도 사실 객체이다.

- 자바스크립트의 배열과 함수는 특수한 객체들이기 때문에 일반 객체에 존재하는 프로퍼티와 메서드를 다 가지고 있음
- 배열과 함수도 객체이고 추가적인 프로퍼티나 메서드를 가질 수 있다는 사실만 알아두기
