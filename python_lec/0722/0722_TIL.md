## Data Structure
#### 데이터 구조 `Data Structure`
- 여러 데이터를 효과적으로 사용, 관리하기 위한 구조 (str, list, dict 등)

#### 데이터 구조 활용
- 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 <span style='color:red;'>메서드</span>를 호출하여 다양한 기능을 활용하기

### 메서드 `method`
- 객체에 속한 함수
- 객체의 상태를 조작하거나 동작을 수행

#### 메서드 특징
- 메서드는 클래스(class) 내부에 정의되는 함수
- 클래스는 파이썬에서 ‘타입을 표현하는 방법’이며 이미 은연중에 사용해왔음
- 예를 들어 help 함수를 통해 str을 호출해보면 class 였다는 것을 확인 가능

#### 지금 시점에 알아야 할 것
메서드는 어딘가(클래스)에 속해 있는 <span style='color:red;'>함수</span>이며,<br>
각 데이터 타입별로 다양한 기능을 가진 메서드가 존재

#### 메서드 호출 방법
- <span style='color:orange;'>데이터 타입 객체</span>.<span style='color:red;'>메서드()</span>
```python
'hello'.capitalize()
```

## 시퀀스 데이터 구조
#### 문자열 조회/탐색 및 검증 메서드
|        메서드      	|                                         설명                                        	|
|:------------------:	|:-----------------------------------------------------------------------------------:	|
|      s.find(x)     	|     x의   첫 번째 위치를 반환. 없으면,   -1을 반환                                  	|
|      s.index(x)    	|     x의   첫 번째 위치를 반환. 없으면,   오류 발생                                  	|
|     s.isupper()    	|     대문자 여부                                                                     	|
|     s.islower()    	|     소문자 여부                                                                   	|
|     s.isalpha()    	|     알파벳 문자 여부      *단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함)    	|

##### .find(x)
- x의 첫 번째 위치를 반환. 없으면, -1을 반환
    
    ```python
    print('banana'.find('a')) # 1

    print('banana'.find('z')) # -1
    ```

##### .index(x)
- x의 첫 번째 위치를 반환. 없으면, 오류 발생
    
    ```python
    print('banana'.index('a'))  # 1

    print('banana'.index('z'))  # ValueError: substring not found
    ```

##### .isupper(x) / .islower(x)
- 문자열이 모두 대문자/소문자로 이루어져 있는지 확인
  - is의 특징 : ~가 있는지 없는지, 맞는지 아닌지를 판단, 따라서 반환값이 True / False로 나옴
  - 내가 만든 함수가 True / False를 반환하면 함수명에 is를 붙이는 것이 좋음

    ```python
    string1 = 'HELLO'
    string2 = 'Hello'
    print(string1.isupper()) # True
    print(string2.isupper()) # False
    print(string1.islower()) # False
    print(string2.islower()) # False
    ```

##### .isalpha(x)
- 문자열이 알파벳으로만 이루어져 있는지 확인
- 문자열의 모든 요소가 알파벳으로 이루어져 있는지 확인
    ```python
    string1 = 'Hello'
    string2 = '123'
    string3 = '123hi9876'
    print(string1.isalpha()) # True
    print(string2.isalpha()) # False
    print(string3.isalpha()) # False
    ```

#### 문자열 조작 메서드 (새 문자열 반환)
-  문자열 원본을 조작하는 것은 X (문자열은 불변의 특성을 가지기 때문)
- s.replace(old,   new[,count]) : [,count] 같이 대괄호로 둘러싸인 것은 선택인자


|                  메서드                 	|                                              설명                                            	|
|:---------------------------------------:	|:--------------------------------------------------------------------------------------------:	|
|       **s.replace(old,   new[,count])**     	|     바꿀 대상 글자를 새로운 글자로 바꿔서 반환 ([,count]는 몇 번 바꿀지에 대한 인자)                                              	|
|             **s.strip([chars])**            	|     공백이나 특정 문자를 제거                                                                	|
|     **s.split(sep=None,   maxsplit=-1)**    	|     공백이나 특정 문자를 기준으로 분리                                                       	|
|       **'separator'.join(iterable)**      	|     구분자로 iterable(반복가능한 개체)의 문자열을 연결한 문자열을 반환                                           |
|              s.capitalize()             	|     가장   첫 번째   글자를   대문자로   변경                                                	|
|                 s.title()               	|     문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로,      나머지는 소문자로 변환    	|
|                 s.upper()               	|     모두   대문자로 변경                                                                     	|
|                 s.lower()               	|     모두   소문자로 변경                                                                     	|
|               s.swapcase()              	|     대↔소문자 서로 변경                                                                      	|

##### .replace(old, new[,count])
- 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
- [,count]는 몇 번 바꿀지에 대한 인자, count 인자를 작성하지 않으면 모든 old 문자들을 변경

    ```python
    text = 'Hello, world!'
    new_text = text.replace('world', 'Python')
    print(new_text) # Hello, Python!

    text = 'Hello, world! world world'
    new_text = text.replace('world', 'Python', 1)
    print(new_text) # Hello, Python! world world
    ```

##### .strip([chars])
- 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
- 아무것도 입력하지 않으면 공백 제거 (.strip())

    ```python
    text = '   Hello, world!   '
    new_text = text.strip()
    print(new_text) # 'Hello, world!'
    ```

##### .split(sep=None, maxsplit=-1)
- 지정한 문자를 구분자로 문자열을 분리하여 문자열의 리스트로 반환
- 인자를 넣어주지 않으면 공백을 기준으로 분리 (.split())

    ```py
    text = 'Hello, world!'
    words = text.split(',')
    print(words) # ['Hello', ' world!'] # ','를 기준으로 나눴으므로 world 앞에 공백이 존재
    ```

##### ‘separator’.join(iterable)
- iterable 의 문자열을 연결한 문자열을 반환
- split과 반대, 구분자(separator)로 리스트를 연결

    ```py
    words = ['Hello', 'world!']
    text = '-'.join(words)
    print(text) # 'Hello-world!'
    ```

##### 기타 문자열 조작 메서드
- .capitalize() : 맨 앞 문자는 대문자로 바꾸고 나머지는 모두 소문자로 변경
- .title() : 첫 문자도 대문자로 바꾸지만 문자열 간에 공백이 있으면 공백 다음 글자를 대문자로 변경
- .upper() : 모두 대문자로 변경
- .lower() : 모두 소문자로 변경
- .swapcase() : 대소문자를 서로 변경, 기존의 대문자는 소문자로, 소문자는 대문자로 변경

```python
text = 'heLLo, woRld!'
new_text1 = text.capitalize()
new_text2 = text.title()
new_text3 = text.upper()
new_text4 = text.swapcase()

print(new_text1) # Hello, world!
print(new_text2) # Hello, World!
print(new_text3) # HELLO, WORLD!
print(new_text4) # HEllO, WOrLD!
```

### 리스트
#### 리스트 값 추가 및 삭제 메서드
|          메서드         	|                                                   설명                                                  	|
|:-----------------------:	|:-------------------------------------------------------------------------------------------------------:	|
|        L.append(x)      	|     리스트   마지막에 항목 x를   추가                                                                   	|
|        L.extend(m)      	|     Iterable m의   모든 항목들을 리스트 끝에 추가 (+=과   같은 기능)                                    	|
|     L.insert(i,   x)    	|     리스트   인덱스 i에 항목 x를 삽입                                                                   	|
|        L.remove(x)      	|     리스트   가장 왼쪽에 있는 항목(첫 번째)   x를   제거     항목이 존재하지 않을 경우,   ValueError    	|
|          L.pop()        	|     리스트   가장 오른쪽에 있는 항목(마지막)을   반환 후 제거                                           	|
|         L.pop(i)        	|     리스트의 인덱스 i에   있는 항목을 반환 후 제거                                                      	|
|         L.clear()       	|     리스트의 모든 항목 삭제                                                                             	|
#### 리스트 값 추가 및 삭제 메서드
|          메서드         	|                                                   설명                                                  	|
|:-----------------------:	|:-------------------------------------------------------------------------------------------------------:	|
|        L.append(x)      	|     리스트   마지막에 항목 x를   추가                                                                   	|
|        L.extend(m)      	|     Iterable m의   모든 항목들을 리스트 끝에 추가 (+=과   같은 기능)                                    	|
|     L.insert(i,   x)    	|     리스트   인덱스 i에 항목 x를 삽입                                                                   	|
|        L.remove(x)      	|     리스트   가장 왼쪽에 있는 항목(첫 번째)   x를   제거     항목이 존재하지 않을 경우,   ValueError    	|
|          L.pop()        	|     리스트   가장 오른쪽에 있는 항목(마지막)을   반환 후 제거                                           	|
|         L.pop(i)        	|     리스트의 인덱스 i에   있는 항목을 반환 후 제거                                                      	|
|         L.clear()       	|     리스트의 모든 항목 삭제                                                                             	|

##### .append(x)
- 리스트 마지막에 항목 x를 추가

    ```python
    my_list = [1, 2, 3]
    my_list.append(4)
    print(my_list) # [1, 2, 3, 4]
    print(my_list.append(4)) # None : append의 반환이 없기 때문
                            # append는 원본을 이미 바꿨으므로 반환이 필요없음
    ```

##### .extend(iterable)
- 리스트에 다른 반복 가능한 객체의 모든 항목을 추가
- iterable을 넣지 않으면 오류 발생
    
    ```py
    my_list = [1, 2, 3]
    my_list.extend([4, 5, 6])
    print(my_list) # [1, 2, 3, 4, 5, 6]

    my_list = [1, 2, 3]
    my_list.extend(5) # TypeError
    my_list.extend([5]) # 오류 발생 X
    print(my_list)  # [1, 2, 3, 5] 
    
    my_list.append([9, 9, 9]) # 리스트를 통째로 넣는 방법
    print(my_list)

    my_list.append([9, 9, 9], 1, 2) # 인자를 한개만 받을 수 있어 오류 발생
    my_list.extend([4, 5, 6], [7, 8, 9]) # 인자를 한개만 받을 수 있어 오류 발생
    ```

##### .insert(i, x)
- 리스트의 지정한 인덱스 I 위치에 항목 x를 삽입
    
    ```python
    my_list = [1, 2, 3]
    my_list.insert(1, 5)
    print(my_list) # [1, 5, 2, 3]
    ```

##### .remove(x)
- 리스트에서 첫 번째로 일치하는 항목을 삭제
    
    ```python
    my_list = [1, 2, 3]
    my_list.remove(2)
    print(my_list)  # [1, 3]

    my_list = [1, 2, 3, 2, 2]
    my_list.remove(2)
    print(my_list) # [1, 3, 2, 2] 첫번째 2만 제거
    ```

##### .pop(i)
- 리스트에서 지정한 인덱스의 항목을 제거하고 반환
작성하지 않을 경우 마지막 항목을 제거 

    ```py
    my_list = [1, 2, 3, 4, 5]
    
    item1 = my_list.pop()
    item2 = my_list.pop(0) # 0번째 인덱스를 지우는 것
    
    print(item1) # 5
    print(item2) # 1
    print(my_list) # [2, 3, 4]
    ```

##### .clear()
- 리스트의 모든 항목을 삭제

    ```py
    my_list = [1, 2, 3]
    my_list.clear()
    print(my_list) # []
    ```

#### 리스트 탐색 및 정렬 메서드
|               문법              	|                                   설명                                 	|
|:-------------------------------:	|:----------------------------------------------------------------------:	|
|     L.index(x)    	|     리스트에   있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환    	|
|            L.count(x)           	|     리스트에서 항목   x의 개수를 반환                                  	|
|            L.reverse()          	|     리스트의 순서를 역순으로 변경 (정렬 X)|
|             L.sort()            	|     리스트를 정렬 (매개변수   이용가능)                                	|

##### .index(x)
- 리스트에서 첫 번째로 일치하는 항목의 인덱스를 반환
    
    ```python
    my_list = [1, 2, 3]
    index = my_list.index(2)
    print(index)  # 1
    ```

##### .count(x)
- 리스트에서 항목 x가 등장하는 횟수를 반환

    ```py
    my_list = [1, 2, 2, 3, 3, 3]
    count = my_list.count(3)
    print(count)  # 3
    ```

##### .reverse()
- 리스트의 순서를 역순으로 변경(정렬 X)
- 변수에 따로 할당하지 않는 이유? 원본을 뒤집었기 때문에 새로운 리스트를 반환할 필요 없기 때문
- reverse의 반환값 없음 (원본을 뒤집었으므로)

    ```py
    my_list = [1, 3, 2, 8, 1, 9]
    my_list.reverse()
    print(my_list)  # [9, 1, 8, 2, 3, 1]
    print(my_list.reverse()) # None
    ```

##### .sort()
- 원본 리스트를 오름차순으로 정렬

    ```python
    my_list = [3, 2, 1]
    my_list.sort()
    print(my_list)  # [1, 2, 3]

    # 내림차순(매개변수 활용)
    my_list.sort(reverse=True)
    print(my_list)  # [3, 2, 1]
    ```


# Copy
## 복사
### 개요
- 파이썬에서는 데이터에 분류에 따라 복사가 달라짐
- “변경 가능한 데이터 타입”과 “변경 불가능한 데이터 타입”을 다르게 다룸

### 복사 유형
#### 복사 유형
1. 할당 (Assignment)
2. 얕은 복사 (Shallow copy)
3. 깊은 복사 (Deep copy)

#### 1. 할당
- 리스트 복사 예시
    - 할당 연산자(=)를 통한 복사는 해당 객체에 대한 **객체 참조를 복사**

        ```py
        original_list = [1, 2, 3]
        copy_list = original_list
        print(original_list, copy_list)  # [1, 2, 3] [1, 2, 3]

        copy_list[0] = 'hi'
        print(original_list, copy_list)  # ['hi', 2, 3] ['hi', 2, 3]
        ```

        ![image](https://github.com/ragu6963/TIL/assets/32388270/f5ded019-54d8-40f4-b259-10140e6ff57f)


#### 2. 얕은 복사
- 리스트 얕은 복사 예시
    - 슬라이싱을 통해 생성된 객체는 원본 객체와 독립적으로 존재
    - a[:]와 .copy() 기능 동일
        
        ```py
        a = [1, 2, 3]
        b = a[:]
        print(a, b)  # [1, 2, 3] [1, 2, 3]

        b[0] = 100
        print(a, b)  # [1, 2, 3] [100, 2, 3]
        ```

        ![image](https://github.com/ragu6963/TIL/assets/32388270/e6ca0423-4824-4822-bc3f-53d61ed551bd)

- 2차원 리스트와 같이 변경가능한 객체 안에 변경 가능한 객체가 있는 경우
    - a와 b의 주소는 다르지만 내부 객체의 주소는 같기 때문에 함께 변경됨
    - 얕은 복사의 한계

        ```py
        a = [1, 2, [1, 2]]
        b = a[:]
        print(a, b)  # [1, 2, [1, 2]] [1, 2, [1, 2]]

        b[2][0] = 100
        print(a, b)  # [1, 2, [100, 2]] [1, 2, [100, 2]]
        ```
        
        ![image](https://github.com/ragu6963/TIL/assets/32388270/3ec9f431-47c8-4332-98b8-45ff86550bb0)

#### 3. 깊은 복사
- 리스트 깊은 복사 예시
    - 내부에 중첩된 모든 객체까지 새로운 객체 주소를 참조하도록 함

        ```py
        import copy


        original_list = [1, 2, [1, 2]]
        deep_copied_list = copy.deepcopy(original_list)

        deep_copied_list[2][0] = 100

        print(original_list)  # [1, 2, [1, 2]]
        print(deep_copied_list)  # [1, 2, [100, 2]]
        ```
        
        ![image](https://github.com/ragu6963/TIL/assets/32388270/b352a3ea-6264-46fc-9f84-f5e915b523d0)

#### 문자 유형 판별 메서드
#### 문자열에 포함된 문자들의 유형을 판별하는 메서드
- `isdecimal()`
    - 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
- `isdigit()`
    - isdecimal()과 비슷하지만, 유니코드 숫자도 인식 ('①’ 도 숫자로 인식)
- `isnumeric()`
    - isdigit()과 유사하지만, 몇 가지 추가적인 유니코드 문자들을 인식 <br>(분수, 지수, 루트 기호도 숫자로 인식)


#### 함수 주의사항
```python
def func2(a):
    a = 3
    # return None이 숨어있음

a = 0
a = func2(a)
print(a) # None : 0 출력되지 X
```
#### 주의
- 바꾸려는 값이 가변형인지 불변형인지 확인 필요
- 리스트는 원본을 바꾸고 문자열은 
```python
s = 'abc'
print('abc'.capitalize()) # 'abc' 문자열에 대해 capitalize 적용하는 것

print(s.capitalize()) # s가 문자열이 아니고 변수이므로 capitalize 적용할 수 없으므로 반드시 변수에 할당하고 출력해야 올바른 결과 출력됨
print(s) # abc 출력 : Abc가 아님, 원본을 바꾸는 것이 아니므로

# 올바른 출력
a = s.capitalize()
print(a)
```

#### 2차원 배열 생성시 주의사항
```python
# 2차원 배열 생성
# 1차원 이상에서는 *로 배열 생성하면 안됨
# 같은 객체를 공유해버리기 때문에 하나의 리스트 값 요소를 바꾸면 모든 내부 리스트 요소가 바뀜
# 1차원 배열이 괜찮은 이유? 1차원 배열은 값이기 때문
l = [[0] * 10] * 5
l[0][0] = 10
l[1] = [2] * 5 # 2가 5개 든 리스트를 완전히 새로 만들기 때문에 이렇게 작성하는 것은 문제 없음

print(l) # 모든 내부 리스트 [0][0] 요소가 10으로 바뀜

# 올바른 2차원 배열 생성
l = [[0] * 10 for _ in range(5)]
l[0][0] = 10
print(l)
```

#### pop 주의사항
- for문 안에서 pop을 사용하는 것은 주의해야함 : l의 길이가 줄어들기 때문에 index out of range 오류 발생할 수 있음
- pop 사용시 while문 권장
```python
l = [1, 2, 3, 4, 5]
for i in range(len(l)):
    t = l.pop()
    # 0부터 4까지 l pop을 하면 l에 남은 요소가 없어 마지막에 index out of range 오류 발생
```

#### 실습 5차. 데이터 구조 1 : 1444.List.pop() List.extend()
```python
# 풀이
def even_elements(lst):
    result = []
    while len(lst) > 0: # while len(lst), while lst != [] (이 줄 3가지 식 모두 같은 의미)
        t = lst.pop(0) # 앞에서부터 pop
        if t % 2 == 0:
            result.extend([t])
        return result


my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = even_elements(my_list)
print(result)
```