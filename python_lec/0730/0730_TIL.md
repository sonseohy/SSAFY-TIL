#### 4835. 구간합 응용
- 구간합 문제에서, 배열 원소 Ai의 크기가 |Ai| <= 10000 이라면? (음수인 경우도 생각)

#### 카운팅 정렬
```python
def Counting_Sort(DATA, TEMP, k):
    # DATA [] : 입력 배열(0 to k)
    # TEMP [] : 정렬된 배열
    # COUNTS [] : 카운트 배열

    COUNTS = [0] * (k + 1)

    for i in range(0, len(DATA)):
        COUNTS[DATA[i]] += 1
    
    for i in range(1, k + 1):
        COUNTS[i] += COUNTS[i - 1]

    # 기준점을 바꾸면 아래와 같은 코드도 가능
    # for i in range(0, k):
    #     COUNTS[i + 1] += COUNTS[i]

    for i in range(len(TEMP)-1, -1, -1):
        COUNTS[DATA[i]] -= 1
        TEMP[COUNTS[DATA[i]]] = DATA[i]
```
- 0 ~ 100만 정도의 자료를 정렬할 때 사용
- 카운팅 정렬에서 카운트 배열 counts를 처음 생성할 때 배열의 크기를 마지막 인덱스가 아닌 갯수만큼 지정해주어야 함 (index out of range 발생 주의)
- for 문의 변수로 사용하는 i, j는 인덱스를 가져오는 경우 주로 사용, 리스트에서 값을 가져오는 경우에는 사용하지 않는 것 권장 (ex. for i in Data (X), for x in Data (O)/ for i in range(N) (O))

```python
DATA = [0, 4, 1, 3, 1, 2, 4, 1]
COUNTS = [0] * 5    # DATA가 0~4까지의 정수

N = len(DATA)       # DATA의 크기
TEMP = [0] * N      # 정렬 결과 저장

# 1단계 : DATA 원소별 개수 세기
for x in DATA:      # DATA의 원소 X를 가져와서 COUNTS[X]에 개수 기록
    COUNTS[x] += 1

# 2단계 : 각 숫자까지의 누적 개수 구하기
for i in range(1, 5):   # COUNT[1] ~ COUNT[4]까지 누적 개수
    COUNTS[i] = COUNTS[i - 1] + COUNTS[i]

# 3단계 : DATA의 맨 뒤부터 TEMP에 정렬하기
for i in range(N - 1, -1, -1): # N - 1부터 0까지 뒤에서부터 가져오는 range 작성
    COUNTS[DATA[i]] -= 1        # 누적개수 1개 감소
    TEMP[COUNTS[DATA[i]]] = DATA[i]

print(*TEMP)
```

- 왜 원본 데이터를 뒤에서부터 가져와 정렬? 앞에서부터 가져와 정렬하면 가장 먼저 나오는 숫자가 TEMP의 해당 숫자들의 자리 중 가장 뒷 자리에 배치됨, 따라서 원본의 데이터 순서가 바뀜
- 원본의 데이터 순서를 그대로 유지하여 정렬하기 위해서 뒤에서부터 데이터를 가져옴

#### 탐욕(Greedy) 알고리즘
- 보통 탐욕 기법이라고 많이 부름 (알고리즘의 접근 방법으로 많이 사용)

#### Baby-gin
- counts = 3 1 1 1 인 경우 run을 먼저 조사후 데이터를 삭제하면 2 0 0 1이 되어버림 (ex. 333456)
- 따라서 triplet을 먼저 조사 후 데이터 삭제
- counts = [0] * 12 에서 12인 이유? run은 i = 7까지만 봐도 되지만 triplet은 i = 9까지 다 봐야함, 따라서 while문의 run에서 index out of range가 나지 않도록 2칸을 더 만들어놓음
```python
n1 = 444521
n2 = 123123

def isBaby(num):
    counts = [0] * 12

    for c in str(num):
        counts[int(c)] += 1

    while num > 0:      # 몫이 0보다 클 때까지 반복
        r = num % 10
        num = num // 10
        counts[r] += 1

    run = tri = 0
    i = 0
    while i <= 9:
        if counts[i] >= 1 and counts[i + 1] >= 1 and counts[i + 2] >= 1:
            run += 1
            counts[i] -= 1
            counts[i + 1] -= 1
            counts[i + 2] -= 1
            continue

        if counts[i] >= 3:
            tri += 1
            counts[i] -= 3
            continue

        i += 1
    

print(isBaby(789888))

```

#### SWEA 4835. 구간합
- 반복문 구간 정하기, 반복문 안에서 합 구해서 저장?
- 최소값 초기값 설정
- 문제에서 N은 10과 100
- 10000 * 100으로 초기화 (문제)
```python
T = int(input())

for test_case in range(1, T + 1):
    N, M = map(int, input().split())
    lst = list(map(int, input().split()))

    i = 0
    sum_m = 0
    min_v = 10e5
    max_v = lst[0]

    while i < N - M + 1:
        for j in range(i):
            sum_m += lst[j]

        print(sum_m)
        if sum_m < min_v:
            min_v = sum_m

        if sum_m > max_v:
            max_v = sum_m

        i += 1

    print(f'#{test_case} {max_v - min_v}')


# answer
for st in range(0, N - M + 1):
    # st에서 시작하여 M개의 합을 구한다.
    sum_value = 0
    for i in range(st, st+M):
        sum_value += lst[i]

# 응용
#

T = int(input())

for test_case in range(1, T + 1):
    N, M = map(int, input().split())
    lst = list(map(int, input().split()))

    sum_value = 0
    min_v = 10e5
    max_v = lst[0]

    for st in range(0, N - M + 1):
        for i in range(st, st + M):
            sum_value += lst[i]

        if sum_value < min_v:
            min_v = sum_value

        if sum_value > max_v:
            max_v = sum_value

    print(f'#{test_case} {max_v - min_v}')
```

#### SWEA 4834. 숫자카드
- 가장많이 들어있는 카드 숫자 출력?
- 카드 숫자들을 리스트로 저장? 
```python
T = int(input())

for test_case in range(1, T + 1):
    card = int(input())
    card_num = input()

    counts = [0] * 10

    card_data = list(card_num)

    for c in card_num:
        n = int(c)
        counts[n] += 1

    max_card = counts[0]
    for c in counts:
        if max_card < c:
            max_card = c

    print(f'#{test_case} {} {c}')


###
num = '49679'
counts = [0] * 10

max_idx = 0
max_value = counts[0]
for i in range(10):
    value = counts[i]
    if max_value <= value:  #
        max_value = value
        max_idx = i

print(max_value, max_idx)

```

#### SWEA 전기버스
```python
# # 정류장 개수 : N
# # 한번 충전시 최대 이동 정류장 수 : K
# # 충전기 설치된 정류장 번호 : M
#
# T = int(input())
#
# for test_case in range(1, T + 1):
#     K, N, M = map(int, input().split())
#     num = list(map(int, input().split()))
#
#     cnt = 0
#     charge_point = 0
#     # for n in range(0, N, K):
#     #     for check in range(n-1, 0, -1):
#
#     while True:
#
# ####
# # 정류장 개수 : N
# # 한번 충전시 최대 이동 정류장 수 : K
# # 충전기 설치된 정류장 번호 : M
#
# T = int(input())
#
# for tc in range(1, T + 1):
#     K, N, M = map(int, input().split())
#     bus_stop = list(map(int, input().split()))
#     bus_stop.append(N)
#
#     current_pos = 0
#     stop = 0
#     for i in range(M):
#         if ((bus_stop[i + 1] - bus_stop[i]) > K) or (bus_stop[0] > K):
#             stop = 0
#             break
#             # bus_stop = [1, 3, 5, 7, 9]
#         if bus_stop[i + 1] - current_pos > K:
#             current_pos = bus_stop[i]
#             stop += 1
#
#     print(f'#{tc} {stop}')
#

# 2
# 충전횟수를 return
# N에 도착하지 않으면 0을 return
def solve():
    for i in range(M+2-1):
        if STOPS[i+1] - STOPS[i] > K:
            return 0

    cur_pos = 0
    cnt = 0
    for i in range(1, M+2):
        if cur_pos + K < STOPS[i]:
            cnt += 1
            cur_pos = STOPS[i-1]
    return cnt

T = int(input())

for test_case in range(1, T + 1):
    K, N, M = map(int, input().split())
    STOPS = [0] + list(map(int, input().split())) + [N]

    print(f'#{test_case} {solve()}')
```

#### SWEA view
```python
# idx 위치의 조망권 개수를 return
def getView(idx):
    max_value = idx 왼 2개, 오 2개 중 큰 값 구함
    if BLD[idx] < max_value:
        return 0
    else:
        return BLD[idx] - max_value

T = 10
for tc in range(1, T + 1):
    N = int(input())
    BLD = list(map(int, input().split()))

    for i in range(2, N-2)
        num = get_view[i]
        sum_v = 0

```

