#### 검색 : 정렬되어 있는 경우
```python
def sequentialSearch2(a, n, key)
    i <- 0
    while i < n and a[i] < key : # i < n을 먼저 써주어야 함, 항상 인덱스 검사를 먼저 해줘야 함
        i <- i + 1
    if i < n and a[i] == key:
        return i
    else:
        return -1
```
- a[i] < key and i < n 이라고 쓰면 a[i] < key에서 error 발생 (out of range 발생)

```python
arr = [4, 9, 11, 23, 2, 19, 7]
arr.sort()
N = 7

def find(key):
    idx = 0
    while idx < N and key > arr[idx]:
        idx += 1

    if idx < N and key == arr[idx]:
        return idx
    '''
    else: # key > arr[idx] or idx == N
        return -1
    '''

    return -1

print(find(8))
print(find(7))
print(find(23))
print(find(2))

```

#### 선택정렬
```python
def selection_sort(arr, N): # arr 정렬대상, N 크기
    for i in range(N-1):    # 주어진 구간에 대해 기준위치 i를 정하고
        min_idx = i         # 최솟값 위치를 기준위치로 가정
        for j in range(i + 1, N):    # 남은 원소에 대해 실제 최솟값 위치 검색
            if arr[min_idx] > arr[j]:
                min_idx = j

        arr[i], arr[min_idx] = arr[min_idx], arr[i] # 구간의 최솟값을 기준위치로 이동

A = [2, 7, 5, 3, 4]

selection_sort(A, len(A))
print(A)
```

```python
for phase in range(N - 1):
    # 구간(phase ~ N-1)에서 제일 작은 값의 위치 찾음
    min_value = arr[phase]
    min_pos = phase
    for idx in range(phase+1, N):
        if min_value > arr[idx]:
            min_value = arr[idx]
            min_pos = idx
    arr[phase], arr[min_pos] = arr[min_pos], arr[phase]

# index를 활용
for phase in range(N - 1):
    # 구간(phase ~ N-1)에서 제일 작은 값의 위치 찾음
    # min_value = arr[phase]
    min_pos = phase
    for idx in range(phase+1, N):
        if arr[min_pos] > arr[idx]:
            # min_value = arr[idx]
            min_pos = idx
    arr[phase], arr[min_pos] = arr[min_pos], arr[phase]
```

#### 검색 : 정렬되어 있지 않은 경우
```python
arr = [4, 9, 11, 23, 2, 19, 7]
N = 7

# arr 리스트에서 key가 위치한 index를 return
# 없으면 -1을 return
# 1. for문 사용
def find(key):
    for idx in range(N):
        if key == arr[idx]:
            return idx

    return -1 # key 값이 arr 리스트에 없을때

print(find(9))
print(find(4))

# 2. while문 사용
def fid(key):
    idx = 0
    while idx < N and key != arr[idx]:
        idx += 1
    '''
    # idx = N이 되어 while문을 나온 경우 arr[idx]에서 out of range 오류 발생
    if key == arr[idx]:
        return idx
    '''
    if idx < N : # 찾았으면
        return idx
    return -1
```

#### 이진 검색 알고리즘
```python
def find(key):
    start = 0
    end = N - 1
    while start <= end:
        m = (start + end) // 2
        if key == arr[m]:
            return m
        if key > arr[m]:
            start = m + 1
        else:  # if key < arr[m]:
            end = m - 1
    return -1
```