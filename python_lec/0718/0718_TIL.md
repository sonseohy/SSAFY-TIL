#### 모듈 `Module`
- 한 파일로 묶인 변수와 함수의 모음<br>특정한 기능을 하는 코드가 작성된 파이썬 파일(`.py`)

#### 모듈을 가져오는 방법
- `import` 문 사용 : import로 가져오면 모듈 이름까지 명시

    ```python
    import math
    
    print(math.sqrt(4))
    ```
- `from` 절 사용 : from으로 가져오면 모듈명을 명시하지 않음 (여러 폴더안(패키지들)의 모듈을 import 할 때는 from절 사용해야함)

    ```python
    from math import sqrt

    print(sqrt(4)) # 모듈의 함수인지 내가 만든 함수인지 구분이 어려울 수 있음
    ```

#### 모듈 주의사항
- 서로 다른 모듈이 같은 이름의 함수를 제공할 경우 문제 발생
- 마지막에 `import`된 이름으로 대체됨

    ```python
    from math import pi, sqrt
    from my_math import sqrt

    ```
    ```python
    # 그래서 모듈 내 모든 요소를 한번에 import 하는 * 표기는 권장하지 않음
    
    from math import *
    ```

#### `as` 키워드
- as 키워드를 사용하여 별칭(alias)을 부여
  - 두 개 이상의 모듈에서 동일한 이름의 변수, 함수 클래스 등을 가져올 때 발생하는 이름 충돌 해결

  ```python
  from math import sqrt
  from my_math import sqrt as my_sqrt
  
  sqrt(4)
  my_sqrt(4)
  ```

#### 패키지 `Package`
- 연관된 모듈들(.py 파일들)을 하나의 디렉토리에 모아 놓은 것
- 패키지들을 여러개 모아 놓은 것 = 라이브러리

#### 패키지 사용하기
- 각 패키지의 모듈을 `import` 하여 사용하기
- 여러 패키지 안에 있는 모듈을 import 할 때는 from절 사용해줘야 함
- 디렉토리 전체 구조
    ```markdown
    📦...
     ┣ 📜sample.py
     ┣ 📂my_package
     ┃ ┣ 📂math
     ┃ ┃ ┗ 📜my_math.py
     ┃ ┣ 📂statistics
     ┃ ┃ ┗ 📜tools.py
    ```
    ```python
    # sample.py

    from my_package.math import my_math
    from my_package.statistics import tools


    print(my_math.add(1, 2))  # 3
    print(tools.mod(1, 2))  # 1
    ```

#### PSL 내부 패키지
- 설치 없이 바로 `import`하여 사용

#### 외부 패키지
- `pip`를 사용하여 설치 후 `import` 필요

#### 패키지 설치
- 최신 버전 / 특정 버전 / 최소 버전을 명시하여 설치할 수 있음

    ```bash
    $ pip install SomePackage
    $ pip install SomePackage==1.0.5
    $ pip install SomePackage>=1.0.4
    ```

#### requests 외부 패키지 설치 및 사용 예시
- requests : 외부 API에 요청을 보내는 패키지

```bash
$ pip install requests
```

```python
import requests


url = 'https://random-data-api.com/api/v2/users'
response = requests.get(url).json()

print(response)
```

#### 패키지 사용 목적
- 모듈들의 이름공간을 구분하여 충돌을 방지 
- 모듈들을 효율적으로 관리하고 재사용할 수 있도록 돕는 역할

## 제어문
### 제어문 `Control Statement`
- 코드의 실행 흐름을 제어하는 데 사용되는 구문<br>
- <span style='color:red;'>조건</span>에 따라 코드 블록을 실행하거나 <span style='color:red;'>반복</span>적으로 코드를 실행
- 조건문과 반복문을 합쳐 제어문이라고 부름

#### 파이썬 반복문에 사용되는 키워드
- `for`
  - 특정 작업을 반복적으로 수행
  - 언제 종료되는지 종료시점이 보임 (종료조건이 자연스럽게 존재)
- `while`
  - 주어진 조건이 참인 동안(거짓이 될 때까지) 반복해서 실행
  - 종료시점이 보이지 않고 종료가 되는 조건이 필요함

### `‘for’` statement
- 임의의 시퀀스의 항목들을 그 시퀀스에 들어있는 순서대로 반복
- for statement의 기본 구조
- - 임시 변수 이름은 순회하는 변수명의 단수 형태로 작성하는 것이 좋음

    ```python
    for 변수 in 반복 가능한 객체:
        코드 블록
    ```

#### 반복 가능한 객체 `iterable`
- 반복문에서 순회할 수 있는 객체<br>
(시퀀스 객체 뿐만 아니라 dict, set 등도 포함)

### 반복 제어
- for문과 while은 매 반복마다 본문 내 모든 코드를 실행하지만<br>
때때로 일부만 실행하는 것이 필요할 때가 있음

#### 반복문 제어 키워드
- `break`
  - 반복을 즉시 중지
- `continue`
  - 다음 반복으로 건너뜀
- `pass`
  - 아무런 동작도 수행하지 않고 넘어감
  - 함수 정의(혹은 반복문)시 내용을 적지 않고 둘 때 에러발생을 막기 위해 사용하기도 함

#### pass 예시
1. 코드 작성 중 미완성 부분
    - 구현해야 할 부분이 나중에 추가될 수 있고, 코드를 컴파일하는 동안 오류가 발생하지 않음
      ```python
      def my_function():
          pass  
      ```
2. 조건문에서 아무런 동작을 수행하지 않아야 할 때
    ```python
    if condition:
        pass  # 아무런 동작도 수행하지 않음
    else:
        # 다른 동작 수행
    ```
3. 무한 루프에서 조건이 충족되지 않을 때 pass를 사용하여 루프를 계속 진행하는 방법
    ```python
    while True:
        if condition:
            break
        elif condition:
            pass  # 루프 계속 진행
        else:
            print('..')
    ```

### List Comprehension
- 간결하고 효율적인 리스트 생성 방법
- 목적 : 리스트 생성

#### List Comprehension 구조
- 특징 : 한 줄로 작성함
```python
[expression for 변수 in iterable]
list(expression for 변수 in iterable)

[expression for 변수 in iterable if 조건식]
list(expression for 변수 in iterable if 조건식)
```

#### List Comprehension 사용 전/후 비교

- 사용 전
    ```python
    numbers = [1, 2, 3, 4, 5]
    squared_numbers = []

    for num in numbers:
        squared_numbers.append(num**2)

    print(squared_numbers)  # [1, 4, 9, 16, 25]
    ```

- 사용 후
    ```python
    numbers = [1, 2, 3, 4, 5]
    squared_numbers = [num**2 for num in numbers] # for문의 변수 num을 사용해 표현식을 작성해야함 (numbers ** 2 (X), num ** 2(O))

    print(squared_numbers)  # [1, 4, 9, 16, 25]
    ```

#### List Comprehension 활용 예시
- 2차원 배열 생성 시 (인접행렬 생성 시)

```python
data1 = [[0] * (5) for _ in range(5)]

# 또는
data2 = [[0 for _ in range(5)] for _ in range(5)]

"""
[[0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0]]
"""
```

### 리스트를 생성하는 방법 비교
```python
# 1. loop
result1 = []
for i in range(10):
    result1.append(i)

# 2. list comprehension
result2 = [i for i in range(10)]
# result2 = list(i for i in range(10))

# 3. map
result3 = list(map(lambda i: i, range(10)))

print(result1)
print(result2)
print(result3)


"""
성능 비교

1. list comprehension
    - 대부분의 경우 가장 빠르고 파이썬스러운(Pythonic) 방법
2. map
    - 특정 상황(예: 기존 함수를 사용할 때)에서 리스트 컴프리헨션과 비슷하거나 약간 더 빠를 수 있음
    - 넣어주는 함수에 따라 속도가 달라지기도 함
3. loop
    - 일반적으로 가장 느리다고 알려져 있지만,
      python 버전이 올라가면서 다른 방식과 비슷하거나 때로는 더 나은 결과를 보이기도 함
    - 복잡한 로직이 필요한 경우에는 여전히 유용하게 사용될 수 있음

결론
- 성능 차이는 대부분의 경우 미미하므로, 
  코드의 가독성과 유지보수성을 고려하여 상황에 맞는 적절한 방법을 선택하는 것을 권장
"""
```

#### help
- 모듈 내부 살펴보기 : 내장함수 help를 사용해 모듈에 무엇이 들어있는지 확인 가능
- ex. help(math)

#### `enumerate(iterable, start=0) `
- iterable 객체의 각 요소에 대해 인덱스와 함께 반환하는 내장함수
- start는 인덱스 시작 번호
- 내장 함수이므로 import 없이 사용 가능
#### enumerate 예시

```python
fruits = ['apple', 'banana', 'cherry']

# enumerate()는 인덱스와 리스트 요소가 패킹된(묶인) 튜플이 나와 임시변수로 들어가므로 임시 변수 2개를 선언해줘야 함
for index, fruit in enumerate(fruits): 
print(f'인덱스 {index}: {fruit}')

"""
인덱스 0: apple
인덱스 1: banana
인덱스 2: cherry
"""
```

#### return 값
- return 값은 1개만 작성하는 것이 원칙이나 파이썬에서 2개 이상을 작성할 경우 파이썬 내부에서 return 값을 묶어 하나의 튜플로 만들어 반환하기 때문에 문제가 없는 것 처럼 보임

#### 실습 4차. 함수와 제어문 2 : 1688. 도서관 사용자 관리 서비스 - 데이터 수집
```python
import requests
from pprint import pprint as print

# 무작위 유저 정보 요청 경로
API_URL = 'https://jsonplaceholder.typicode.com/users/'

dummy_data = []

for i in range(1, 11):
    # API 요청
    response = requests.get(f'{API_URL}{i}')
    # JSON -> dict 데이터 변환
    parsed_data = response.json()
    
    name = parsed_data['name']
    dummy_data.append(name)


print(dummy_data)

```

#### 실습 4차. 함수와 제어문 2 : 1689. 도서관 사용자 관리 서비스 - 데이터 처리
```python
import requests
from pprint import pprint as print

# 무작위 유저 정보 요청 경로
API_URL = 'https://jsonplaceholder.typicode.com/users/'

dummy_data = []

for i in range(1, 11):
    # API 요청
    response = requests.get(f'{API_URL}{i}')
    # JSON -> dict 데이터 변환
    parsed_data = response.json()
    
    company = parsed_data['company']['name']
    lat = parsed_data['address']['geo']['lat']
    lng = parsed_data['address']['geo']['lng']
    name = parsed_data['name']


    if -80 < float(lat) < 80 and -80 < float(lng) < 80:
        dummy_data.append({'company':company, 'lat':lat, 'lng':lng, 'name':name})

print(dummy_data)
```

#### 실습 4차. 함수와 제어문 2 : 1690. 도서관 사용자 관리 서비스 - 블랙리스트 관리
```python
import requests

dummy_data = []

for i in range(1, 11):
    API_URL = 'https://jsonplaceholder.typicode.com/users/' + str(i)
    response = requests.get(API_URL)
    parsed_data = response.json()
    if -80 < float(parsed_data['address']['geo']['lat']) < 80 and -80 < float(parsed_data['address']['geo']['lng']) < 80:
        dummy_data.append({'company':parsed_data['company']['name'], 'lat':parsed_data['address']['geo']['lat'], 'lng':parsed_data['address']['geo']['lng'], 'name':parsed_data['name']})

black_list = [
    'Hoeger LLC',
    'Keebler LLC',
    'Yost and Sons',
    'Johns Group',
    'Romaguera-Crona',
]

censored_user_list = {}

def create_user(data_list):
    for user in data_list:
        check = censorship(user['company'], user['name'])
        if check:
            censored_user_list[user['company']] = [user['name']]

# list([user['name']])을 사용하면 한 글자씩 저장되는 이유? list()함수는 괄호 안에 시퀀스 데이터를 하나씩 불러와 하나의 리스트로 저장해주는 함수인데 user['name']은 문자열 이므로 list() 함수 안에 사용하면 시퀀스 데이터인 문자열을 한글자씩 리스트의 값으로 저장해버리기 때문
        
    return censored_user_list
    
def censorship(user_company, user_name):
    if user_company in black_list:
        print(f"{user_company} 소속의 {user_name} 은/는 등록할 수 없습니다.")
        return False
    else:
        print("이상 없습니다.")
        return True
    

print(create_user(dummy_data))

```

#### 실습 4차. 함수와 제어문 2 : 1691. 도서관 사용자 관리 서비스 - 데이터 유효성 검사