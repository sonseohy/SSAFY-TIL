#### 스택의 삽입 / 삭제 과정
- push (값) : top을 한칸 올리고 값을 삽입
- pop : top의 값을 빼고 top을 한 칸 내림

#### 스택의 push 알고리즘
- append 메소드 통해 리스트 마지막에 데이터를 삽입
    (but. append는 조금 느림 -> append로 리스트에 추가할 때 공간을 한 칸만 만들지 않고 어느정도 공간을 만든 후 부족하면 또 어느정도 공간을 추가)
```python
def push(item):
    s.append(item)
```

#### 스택의 구현 : push
- 사용할 스택의 크기를 먼저 정해놓고 시작 (size = 10)
- 그 크기만큼의 빈 배열을 만들고 첫 인덱스를 -1로 초기화 (stack = [0] * size, top = -1)
- top은 global로 선언 (global로 선언하지 않으면 top을 읽어오는 것은 가능하나 top을 수정할 수 없음)
```python
def push(item, size):
    global top
    top += 1
    if top == size:     # stack이 꽉 차 있을 때
        print('overflow!')
    else:
        stack[top] = item

size = 10
stack = [0] * size
top = -1

# stack에 값 넣는 법 1
push(10, size)
# stack에 값 넣는 법 2
top += 1        # push(20)을 풀어쓴 코드
stack[top] = 20
```

#### 스택의 pop 알고리즘
```python
def my_pop():   # 내장함수 pop과 이름이 겹치면 안되므로
    if len(s) == 0:
        # underflos
        return
    else:
        return s.pop()  # pop 괄호안에 아무것도 적지않으면 제일 뒷 값을 pop(0)을 하면 앞의 값 pop
```

#### 스택의 구현 : pop
```python
def my_pop():
    global top
    if top == -1:
        print('underflow')
        return 0 # 밑의 else문과 형식을 맞춰주기 위해 0 값을 반환
    else:
        top -= 1
        return stack[top+1] # return 후에 값을 감소시킬 수 없어서 top+1을 반환
        # 값을 별도로 지워줄 필요는 없음 (상관 X)

print(pop())

# 간단한 방식으로 코드를 구현할 때
if top > -1:    # pop()
    top -= 1
    print(stack[top+1]) # == print(stack[top]) '\n' top -= 1
```

```python
# while문으로 pop 구현
while top > -1:
    tmp = stack[top]
    top -= 1
```

#### 스택의 응용 1. 괄호 검사
- 조건 오류
- 스택이 비어있는데 닫는 괄호가 나왔을 경우
- 괄호 짝이 안 맞는 경우 (여는 소괄호가 스택에 있는데 닫는 중괄호가 들어왔을때)
- 괄호 수식이 끝났는데 스택에 괄호가 남아있을 경우

#### 스택의 응용 2. functin call
- 함수가 호출될 때 매개변수 자리가 메모리에 생성되고 매개변수 자리에 넘어온 값을 저장, 함수 실행이 종료되면 리턴값을 반환 후 매개변수는 (펑) 메모리에서 사라짐(지워짐?없어짐?) (값을 없애지 않아도 되는 이유? 나중에 그 메모리 자리에 파이썬 내부에서 다른 변수나 값을 덮어쓸 것이기 때문)
- 지우는 동작을 하지 않았던 이유? pop이후 새로운 값이 push되면 내용이 덮어써지기 때문 

#### 재귀함수
- 중단하는 조건을 먼저 써주어야 함

#### 참고
- 알고리즘 문제풀 때 push는 append, pop은 파이썬 내장함수 pop쓰면 빠르게 풀 수 있음
- 단, pop할 시 stack에 값이 있는지 반드시 확인하는 코드 작성해야함