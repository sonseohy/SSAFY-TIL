#### 반복(Iteration)과 재귀(Recursion)
- 아래처럼, 11 ~ 33 까지 출력하는 프로그램을 작성하시오.
```python
11
12
13
21
22
23
31
32
33
```

```python
for i in range(1, 4):
    for j in range(1, 4):
        print(f'{i}{j}')
```


- 재귀를 연습하기 전, 알아야 할 함수의 특징 1
  - 정수 타입은 원본이 바뀌지 않는다.
```python
def func(x):
    x += 1

x = 10
func(x)
print(x)    # 10 (함수 안의 x와 바깥의 x는 서로 다른 메모리를 가지는 "다른 객체이다"

def func(x):
    x[0] += 1   # x 리스트의 첫번째로 가서 값을 +1 (직접 들어가서 값을 바꿈)

x = [10]    # 함수에 전달해주는 값이 참조값(주소값)
func(x)
print(x)    # [11]
```

- Python은 재귀 깊이 제한을 1000번으로 제한
- 재귀도 결국 함수를 호출하는 것이기 때문에 함수 호출시의 값을 복사해서 사용하려면 메모리를 차지해야함 -> 값만 복사해서 사용하려면 메모리를 사용함 -> 메모리를 먹기 때문에 제한을 둬서 사용하게 함
- 궁금하면 깊이 제한을 왜 1000으로 두었는지 검색해보기

```python
def KFC(x):
    KFC(x+1)

KFC(0)
print('끝')
```

- 재귀호출
```python
def func(x):
    # 1. 기저 조건 (종료 조건)
    if x == 6:
        return

    # 2. 다음 재귀 호출 전
    print(x, end=' ')
    # 3. 재귀 호출
    func(x + 1)     # 다음 재귀 호출에서는 현재보다 x 값이 1이 커야한다.
    # 4. 호출하고 돌아왔을 때
    print(x, end=' ')

start = 0
func(start)
```

- [도전] 중복순열 [1, 1, 1] ~ [6, 6, 6]까지 출력하는 코드
```python
path = []   # 경로를 기록할 리스트

def KFC(x):
    if x == 4:
        print(*path)
        return

    for i in range(1, 7):
        path.append(i)
        KFC(x + 1)
        path.pop()

KFC(1)
```
- live.ver
```python
path = []   # 경로를 기록할 리스트

# 0부터 시작, 3개를 뽑은 경우 종료
def recur(level):
    if level == 3:
        print(*path)
        return

    # 2. 후보군을 반복하면서
    for i in range(1, 7):
        # 2.1 재귀 호출 전 : 경로 기록
        path.append(i)
        # 2.2 다음 재귀 호출 (파라미터 전달)
        recur(level + 1)
        # 2.3 돌아왔을 때 : 사용했던 경로 삭제
        path.pop()


recur(0)    # 호출 : 시작점을 같이 전달해주는 경우가 많다.
```

- [1 1 1 1 1] ~ [4 4 4 4 4] 중복순열 코드
```python
path = []

def KFC(x):
    if x == 6:
        print(*path)
        return

    for i in range(1, 5):
        path.append(i)
        KFC(x+1)
        path.pop()

KFC(1)
```

- 중복 없는 순열 구현 방법
```python
path = []   # 경로를 기록할 리스트

# 0부터 시작, 3개를 뽑은 경우 종료
def recur(level):
    if level == 3:
        print(*path)
        return

    # 2. 후보군을 반복하면서
    for i in range(1, 7):
        # i가 이미 뽑혔다면, pass 해라 -> 중복제거 (but. 비효율적인 코드)
        # 아래 코드의 단점 : "in" = O(n) (n = path의 길이만큼 걸림 -> len(path)만큼)
        # 시간 초과 위험도가 높다! (가지가 많을 경우)
        if i in path:
            continue

        # 2.1 재귀 호출 전 : 경로 기록
        path.append(i)
        # 2.2 다음 재귀 호출 (파라미터 전달)
        recur(level + 1)
        # 2.3 돌아왔을 때 : 사용했던 경로 삭제
        path.pop()


recur(0)    # 호출 : 시작점을 같이 전달해주는 경우가 많다.
```

- 위의 코드의 시간 초과 위험도를 줄이기 위해 배열을 하나 더 사용 : used 배열을 이용해 사용 여부를 기록
```python
path = []   # 경로를 기록할 리스트
used = [0] * 7  # 1 ~ 6 숫자의 사용 여부를 기록할 리스트

# 0부터 시작, 3개를 뽑은 경우 종료
def recur(level):
    if level == 3:
        print(*path)
        return

    # 2. 후보군을 반복하면서
    for i in range(1, 7):
        if used[i] == 1:    # if used[i]: 로 써도 가능
            continue
        # 2.1 재귀 호출 전 : 경로 기록 + 사용 기록
        used[i] = 1
        path.append(i)
        # 2.2 다음 재귀 호출 (파라미터 전달)
        recur(level + 1)
        # 2.3 돌아왔을 때 : 사용했던 경로 삭제 + 사용 여부 초기화
        path.pop()
        used[i] = 0

recur(0)    # 호출 : 시작점을 같이 전달해주는 경우가 많다.
```

- 완전탐색 문제 1. 주사위 눈금의 합
```python
path = []

# 주사위 몇 개 던졌는지, 주사위의 합이 몇인지?
def recur(level, total):
    # 가지치기 : 이미 10을 넘는 경우의 수는 계산할 필요가 없다.
    if total > 10:
        return

    if level == 3:
        # 10 이하인가?
        # 기저 조건이 return만 있는 것이 아닌 특정 조건을 써줄 수도 있음
        if total <= 10:
            print(path)

        return

    # 후보군 탐색
    for i in range(1, 7):
        # i의 의미 : 주사위 숫자
        path.append(i)
        recur(level + 1, total + i)     # 주사위 결과를 더하여 전달
        path.pop()

recur(0, 0)
```