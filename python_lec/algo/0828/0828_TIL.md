### BST (Binary Search Tree)
- Data들을 빠르게 검색할 수 있도록 체계적으로 저장을 해 두고, 최대 O(log n)의 빠른 속도로 값을 검색할 수 있는 자료구조
- log n 에서 밑은 2 (시간복잡도의 log에서 밑은 항상 2)
- ex. 데이터가 1억개가 있을 때 O(log n)은 몇 번만에 검색? 27번
- 빠르게 검색될 수 있도록, 특정 규칙을 갖는 이진트리 형태로 값을 저장해둔다.

#### 리스트 VS BST
- BST는 리스트보다 더 빠른 삽입 / 삭제 / 탐색이 가능하다.
- 리스트 성능
  - 삽입 : O(n), 단 맨 끝 삽입은 O(1) -> 리스트는 삽입시 최악의 경우 가장 앞에 삽입하면 n만큼의 시간 소요되므로 O(n)
  - 삭제 : O(n), 단 맨 끝 삭제는 O(1)
  - 탐색 : O(n) -> 처음부터 탐색하기 때문

- BST 성능
  - 삽입 : 평균 O(logN)
  - 삭제 : 평균 O(logN)
  - 탐색 : 평균 O(logN)

- 파이썬 공식 Library에는 Binary Search Tree 자료구조가 내장되어 있지 않아 직접 구현해서 사용해야 함

#### BST 동작 원리 - 삽입 1
- 부모 노드보다 크면 오른쪽, 작으면 왼쪽에 데이터 삽입

- BST는 반드시 완전 이진 트리일까? (X)

- if. 정렬된 자료 1, 2, 3, 4, 5, 6, 7이 들어왔을때 : 리스트랑 BST가 차이가 없는 경우에 해당함, 최악의 경우에 해당하며 O(N)까지 늘어날 수 있음

#### BST 동작 원리 - 순회
- BST에서 DFS 중위 순회를 하게 되면 key 값이 작은 순서대로 탐색이 가능하다 = 오름차순 데이터를 얻을 수 있다.

#### 이진 탐색 트리 - 성능
- 탐색, 삽입, 삭제 시간은 트리의 높이만큼 (log N ~ N) 시간이 걸린다.

#### 이진 탐색 트리 - 연산 연습
- 삭제 연산
  - 삭제 시에도 부모노드보다 작으면 왼쪽, 크면 오른쪽이라는 규칙은 깨지면 안됨, 즉 BST 규칙을 유지해야 함
  1. 리프 노드 삭제는 그냥 삭제 가능 (BST 규칙이 깨지지 않음)
  2. 자식이 하나 있는 노드를 삭제하는 경우 자식을 부모 노드에 연결 후 삭제
  3. 자식이 두 개 있는 노드를 삭제하는 경우 왼쪽 서브 트리의 가장 큰 값이나 오른쪽 서브 트리의 가장 작은 값이 삭제하는 노드의 자리에 오면 규칙이 깨지지 않음 (값 복사 후 삭제)
- 삭제가 logN인 이유? 지우려는 노드를 탐색하기 때문, 탐색 후 삭제를 해야하기 때문

### 힙 (Heap)
- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- BST, 힙 모두 노드 값 중복은 상관없음
- 힙의 키를 우선순위로 활용하여 우선순위 큐를 구현할 수 있다.
- 삽입의 시간 복잡도 : N개의 데이터를 힙으로 만든다 -> N * log N (한번 연산은 log N)
- 삭제의 시간 복잡도 : logN + a -> O(log N)

#### 최대 힙
1. 완전 이진 트리
2. 부모 > 자식
- 삽입 : 일단 맨 뒤에 삽입, 비교 후 내 위치를 찾아감 (비교와 swap연산 발생)
- 형제 노드끼리 보는 것은 의미 없음, 왼쪽 형제가 더 커도 상관 X
- 부모 노드끼리만 비교 (왼쪽, 오른쪽 신경쓰지 X)

#### 힙 연산 - 삭제
- 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
- 루트 노드의 원소를 삭제하여 반환한다.
- 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.
- 오른쪽 서브 트리의 값과 바꾸는 이유? 왼쪽 서브트리와 루트 노드 간의 규칙을 깨지 않기 위해

