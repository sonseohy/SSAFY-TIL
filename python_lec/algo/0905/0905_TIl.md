### 백트래킹 응용
- 여러가지 선택지(옵션)들이 존재하는 상황에서 한가지를 선택
- 선택이 이루어지면 새로운 선택지들의 집합이 생성됨
- 이러한 **선택을 반복**하면서 최종 상태에 도달한다.
  - 올바른 선택을 계속하면 목표 상태(goal state)에 도달한다.
- 계층 구조로 트리 형태처럼 나옴 (but. 트리는 아님, 트리 형태로 나오는 것)

#### 백트래킹과 깊이 우선 탐색과의 차이
- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임 (Prunning 가지치기)
- 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단
- 깊이 우선 탐색을 가하기에는 경우의 수가 너무 많음. 즉, N! 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능한 문제 (중복 가능한 경우 : N^N)
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간 (Exponential Time)을 요하므로 처리 불가능

#### N-Queen 문제
- n x n 체스판에서 n개의 Queen들이 서로 위협하지 않도록 배치하는 문제
- 아무것도 고려하지 않고 8개를 배치하는 경우의 수 : 64 C 8 (최악의 경우)
- 한 줄(가로)에 2개 이상 배치하지 않고 8개를 배치하는 경우의 수 : 8 ^ 8
- 가로 한 줄, 세로 한 줄 모두 2개 이상 배치하지 않는 경우의 수 : 8!
- O(N!)이 11 이상이면 가지치기가 반 이상의 경우의 수를 없애줌
- 반 이상의 경우의 수를 없애주는 것이 안보일 때 : DP(반복을 재계산 하지 않도록), 그리디(규칙이 존재하거나) 생각

#### 백트래킹 개념
- 백트래킹 알고리즘 절차
  1. 상태 공간 트리의 깊이 우선 검색을 실시
  2. 각 노드가 유망한지를 점검 : **설계단계에서 유망하지 않은 경우를 생각하고 구현해야 하는 것이 핵심** (반례도 고려)
  3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

- 백트래킹 기본구조
```python
# 중복 순열

arr = [i for i in range(1, 4)]
visited = [0] * 3


def dfs(level):
    if level == len(arr):
        print(*visited)
        return

    for i in range(len(arr)):
        # 가지치기 : 중복된 숫자 제거
        # if arr[i] in visited:
        #     continue

        visited[level] = arr[i]
        dfs(level + 1)
        # visited[level] = 0


dfs(0)
```

### 트리
- 싸이클이 없는 무향(방향이 없다 == 양방향) 연결 그래프
  - 두 노드(정점) 사이에는 유일한 경로가 존재한다. (= 사이클이 없다)
  - 각 노드는 최대 하나의 부모 노드가 존재할 수 있다.
  - 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다.
- 비선형 구조
  - 원소들 간에 1:n 관계를 가지는 자료구조
  - 원소들 간에 계층관계를 가지는 계층형 자료구조
- 트리의 중간에 기존의 노드를 삭제할 경우 (삭제가 발생하는 문제는) 1차원 리스트 사용 X -> 연결 리스트 or _?_ 사용