#### MST(최소비용신장트리) 구현 방법
1. Prim 알고리즘 : 정점을 기준으로 생각
2. Kruskal 알고리즘 : 간선을 기준으로 생각
- 공통점 : 그리디 방식으로 접근 (작은것 부터 선택)

#### Prim 알고리즘
- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST 만들어가는 방식
- 임의의 정점에서 시작해 인접한 정점들 중 최소 비용의 간선이 존재하는 정점 선택 (모든 정점이 선택될 때까지)
- BFS + 최소비용
- 선택되지 않은 정점들 중에서 하나를 선택 후 해당 정점은 다시 보지 않도록 visited 체크
- BFS : queue 활용 + 가장 가중치가 적은 것을 먼저 꺼내고 싶다
    1. sort (매번 O(NlogN))
    2. 최소힙 (heapq) (삽입, 삭제 = O(logN), 최소힙은 완전이진트리)

#### Kruskal 알고리즘
- 최초, 모든 간선을 가중치에 따라 오름차순 정렬
- 가중치가 가장 낮은 간선부터 선택하면서 트리 증가시킴 (사이클이 존재하면 다음으로 가중치가 낮은 간선 선택)
- n-1개의 간선이 선택될 때가지 반복
- kruskal은 visited를 사용하지 않고 union find를 통해 방문 확인 (visited 대신 parents 관리)
- union find를 통해 사이클 판별
    - union find는 방문을 한 집합(같은 그래프)과 아직 방문 전 집합 두 가지로 나뉨
- 간선을 오름차순 정렬 후 작은 간선부터 방문 -> 사이클 발생하면 통과

#### union에서 find 비교 시 주의사항
- 비교를 할 때 if parent[0] == parent[1]: continue로 비교하면 오류가 발생 -> 밑의노드들은 대표자가 변경되지 않은 것이 있을 수 있기 때문
- if find(0) == find(1) : continue 와 같이 대표자를 비교해주어야 함

#### 최단경로 (Dijkstra)
- 두 정점 사이의 경로들 중 간선의 가중치 합이 최소인 경로
- 하나의 시작 정점에서 끝 저점까지의 최단 경로 : 다익스트라 알고리즘(음의 가중치 허용 X), 벨만 포드 알고리즘(음의 가중치 허용)
- 모든 정점들에 대한 최단 경로 : 플로이드-워샬 알고리즘
- [참고] 다익스트라 증명 : 귀납법
- BFS queue + 누적값이 적으면 먼저 방문 -> 최소 힙(heapq)
- 누적거리 기록 리스트를 모두 큰 값(inf)으로 설정
- visited를 따로 쓰지 않아도 됨 -> 최단거리가 설정되면 다른 어떠한 경로도 그보다 작은 거리가 나올 수 없으므로
- 핵심은 누적값
- 다익스트라는 음의 가중치를 허용하지 않으므로 문제 잘 확인하기