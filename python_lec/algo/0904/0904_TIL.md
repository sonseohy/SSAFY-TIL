### 병합 정렬
- 외부 정렬의 기본이 되는 정렬 알고리즘
- 다수의 프로세서 병렬화하기 위해 활용됨 (동시에 여러 곳에서 정렬하겠다)
- low-level 지망시 반드시 공부해야 하는 기본기 (기본적인 내용)

### 퀵 정렬
- pivot을 맨 왼쪽의 값으로 했을 때
  - 장점 : 간단하고 구현이 쉬움
  - 단점 : 역순 정렬되어있을 때 N^2 의 시간 발생
  - 단점 해결을 위해 pivot 설정을 중앙값 혹은 중간값으로 설정
- pivot 설정에 따라 성능이 매우 다를 수 있다 -> pivot 설정이 중요
- 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘

#### Hoare-Partition 알고리즘
- 처음과 끝을 이동시키면서 중앙에서 만나는 방식
- i는 증가시키면서 j는 감소시키면서 바꿔야 하는지 확인
- i는 오른쪽으로 가면서 P보다 큰 값을, j는 왼쪽으로 가면서 P보다 작은 값을 찾으면 stop 후 swap
- 이후 마지막에 pivot을 가운데로 옮김
- i와 j가 같은 인덱스 값일 때도 pivot과 i, j값이 각각 큰지 작은지 비교 후 교차되었을때 pivot 옮김

- j와 i가 교차하면 파티션 1회 끝
- j 자리에 pivot 옮김 -> pivot 자리는 확정

#### Lomuto partition 알고리즘
- Hoare partition보다 느리므로 알고만 있어도 됨
- 느린 이유? swap이 더 많이 발생하기 때문 (바꿔주는 과정이 더 많은 partition)
- 과정
  - 무조건 제일 우측을 pivot으로 잡음
  - i를 -1, j를 0 index에서 시작 (제일 왼쪽에서 같이 출발)
  - pivot보다 큰 수를 만날 때까지 i와 j가 왼쪽으로 같이 이동
  - pivot보다 크면 i만 정지, j는 그대로 왼쪽으로 감
  - i가 정지한 이후, j는 pivot보다 작은 수를 만나면 정지
  - i와 j를 바꿔줌
- 같은 수가 많을 때 lomuto 알고리즘의 문제가 많이 생김 (swap이 많이 발생)
- 역순 정렬된 데이터에서 최악

#### 퀵 정렬 시간복잡도
- **평균적**으로 매우 빠르기 때문에 대용량 데이터에서 많이 쓰임 -> 시간복잡도 : O(NlogN)
  - pivot을 찾아가는 생각에서 N번 반복 (Partitioning 작업이 N 걸림)
  - 분할 작업이 log N 걸림
  - 최악의 경우 분할 작업이 N번까지 갈 수 있기 때문에 O(N^2) 걸릴 수 있음
- 최악의 경우 : O(N^2) - 역순 정렬된 데이터

### 이진 검색
- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
- 정렬하는 시간 O(N log N), 이진 검색하는 시간 O(log N)
- 정렬되지 않은 데이터는 N log N + log N의 시간이 걸리고, 정렬된 데이터는 O(log N) 시간이 걸림

- 정렬된 데이터를 기준으로 특정 값이나 범위(B형, 코테)를 검색하는데 사용
- 이진 검색을 활용한 심화 학습 키워드 : Lower Bound, Upper Bound (이진 검색으로 범위도 찾을 수 있음), parametric search
  - 정렬된 배열에서 특정 값 이상(이하)가 처음으로 나타나는 위치를 찾는 알고리즘

#### 참고
- O(N)은 O(log N), O(N^2)은 O(Nlog N)으로 줄이도록 노력