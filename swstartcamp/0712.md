### ! 자리 옮기면 자격 증명 관리자 - windows 자격 증명에서 github 아이디, pw 지우기

## gitignore
- gitignore : Git에서 특정 파일이나 디렉토리를 추적하지 않도록 설정하는 데 사용되는 텍스트 파일 (프로젝트에 따라 공유하지 않아야 하는 것들도 존재하기 때문, git에 올리고 싶지 않은 파일 설정)
- .git이 있는 폴더에서 .gitignore 파일 생성
- .gitignore 파일에 파일명 작성하면 해당 파일은 생성해도 working directory에 올라가지 않아 git status를 했을 때 untracked file에 나타나지 않음
- gitignore 주의사항 : 이미 git의 관리를 받은 이력이 있는 파일이나 디렉토리는 나중에 gitignore에 작성해도 적용되지 않음(git rm --cached로 캐시 삭제후 가능?)
- 한번 staging area에 올라가서 추적당한 파일은 다시 ignore 되지 않음
- git add 한 파일은 이미 staging area에 올라갔기 때문에 추적당하므로 이후 git ignore에 추가해도 파일이 무시되지 않고 존재
- [gitignore.io](https://www.toptal.com/developers/gitignore/) : 프로젝트에 맞는 뺏으면 하는 파일 알려주는 사이트
- 폴더 만들면 제일 처음 .gitignore 파일 생성하는 것 추천
- fork : 다른사람 repository를 내 repository로 복사
- ex. 

## README.md
- README.md 파일? 프로젝트에 대한 설명, 사용 방법, 문서화 된 정보들을 포함하는 역할,  Markdown형식으로 작성, 반드시 저장소 최 상단에 위치해야 원격저장소에 잘 출력됨
- .git 파일 있는 폴더에 README.md 파일 생성해야 소개글이 레포지토리 첫 화면에 바로 나옴

## git 기타 명령어
- git remote -v : 현재 로컬 저장소에 등록된 원격 저장소 목록 보기
- git remote rm (원격저장소이름) : 현재 로컬 저장소에 등록된 원격 저장소 삭제

## git revert (commit_id)
- 특정 commit을 없었던 일로 만드는 작업
- 변경 사항을 안전하게 실행 취소할 수 있도록 도와주는 순방향 실행 취소 작업
- commit_id는 git log --oneline에서 확인, 꼭 다 쓰지 않아도 구분할 수 있는 수준으로 잘라서 입력가능
- 이미 push하고 원격저장소에 remote 된 상태에서 commit을 취소하고 전 단계로 돌아가고 싶을 때 다른 연결된 로컬 저장소에 pull이 되었다는 가정 하에 commit을 취소하면 이미 pull이 되었으므로 commit 취소 후 push 했을 때 충돌 발생 = 따라서 revert는 commit을 취소한 상태의 파일을 이미 commit한 이후 시점에 다시 commit 하여 commit을 위에 쌓는 형식으로 commit을 없었던 일로 만듦
- commit 전 상태를 복사해서 새 commit으로 생성하는 느낌
- git revert commit_id commit_id : commit_id를 여러개 스페이스로 분류해 작성하면 한꺼번에 실행 취소 가능
- git revert commit_id..commit_id : commit_id~commit_id까지 revert

## git reset [옵션] <commit_id>
- 되돌리기 (진짜 어느 시점으로 되돌아감, 사용시 주의)
- 특정 commit으로 돌아간 후 commit 삭제
- reset 옵션 : --soft, --mixed, --hard
- --soft : 삭제된 commit 기록을 staging area에 남김
- --mixed : 삭제된 commit 기록이 working derectory에 존재(add 전 상태로)
- --hard : 기록된 내역이 모두 삭제
- 이미 삭제한 commit으로 다시 돌아가고 싶다면? git reflog : HEAD가 이전에 가리켰던 모든 commit을 보여줌, reset의 --hard 옵션을 통해 지워진 commit도 reflog

## python
- python에서는 'dust <= 80 and dust > 30' 를 '30 < dust <= 80' 으로 작성 가능
- print(n, end=" ") : n값 출력후 다음 출력값을 다음줄이 아닌 같은 줄에 공백으로 띄고 출력하고 싶다면 , 이후 end=" "를 붙여주면 같은 줄에 출력 가능

```python
# 001011 : 첫 1을 만나기 전 0의 개수를 세는 문제
n = input()
cnt = 0

idx = 0
# n이 input으로 받은 것은 문자열이므로 0이 아닌 '0'
while idx < len(n) and n[idx] == '0':
    idx += 1
    cnt += 1
print(cnt)
# 0000 같이 0만 있는 경우가 있으므로 인덱스 범위가 초과하는 오류가 발생, 따라서 idx 범위를 길이만큼으로 한정
# 항상 범위 비교 먼저한 후 데이터 비교하기
```

```python
# 001011 : 1과 1 사이에 있는 0의 개수를 세는 문제
n = input()
cnt = 0
idx = 0

for i in n:
    idx += 1
    if i == '1':
        while idx < len(n) and n[idx] == '0':
            idx += 1
            cnt += 1
print(cnt)
```

```python
dusts = list(map(int, input().split()))
cnt = 0
sum = 0

# dust 리스트의 길이를 계산하는 코드(len 함수를 for문으로)
for i in dusts:
    cnt += 1

for j in range(cnt):
    print(dusts[j])

sum = 0
for idx in range(0, cnt, 2):
    sum = sum + dusts[idx]
print(sum)
```
- list(map(int, input().split()))
  - input().split(): input으로 데이터를 받아 공백 단위로 잘라 리스트에 (string)값으로 저장함
  - map(int, input().split()) : input으로 받은 값이 string이므로 각각 string 값을 int로 바꿔 저장해줌
  - list(map(,)) : list 형태로 보여줌
- range(0, cnt, 2) : 0부터 cnt -1까지 2 간격만큼 

```python
# 사용자에게 값을 입력받아 홀수번째 인덱스 값 합과 짝수번째 인덱스 값 합 비교
n = list(map(int, input().split()))
cnt = 0
odd_sum = 0
even_sum = 0

# n의 총 개수
for i in n:
    cnt = cnt + 1

# 짝수 합
for idx in range(0, cnt, 2):
    odd_sum = odd_sum + n[idx]
# 홀수 합
for idx in range(1, cnt, 2):
    even_sum = even_sum + n[idx]

if odd_sum > even_sum:
    print('홀수')
elif odd_sum < even_sum:
    print('짝수')
else:
    print('같다')
```
